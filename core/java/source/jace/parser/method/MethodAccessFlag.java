package jace.parser.method;

import jace.parser.*;

import java.util.*;


/**
 * Represents an access flag for a ClassMethod.
 *
 * @author Toby Reyelts
 *
 */
public class MethodAccessFlag {

  /** Declared public; may be accessed from outside its package
   */
  public static final MethodAccessFlag PUBLIC = new MethodAccessFlag( 0x0001, "public" );
  
  /** Declared private; accessible only within the defining class
   */
  public static final MethodAccessFlag PRIVATE = new MethodAccessFlag( 0x0002, "private" );
  
  /** Declared protected; may be accessed within subclasses
   */
  public static final MethodAccessFlag PROTECTED = new MethodAccessFlag( 0x0004, "protected" );
  
  /** Declared static
   */
  public static final MethodAccessFlag STATIC = new MethodAccessFlag( 0x0008, "static" );
  
  /** Declared final; may not be overridden.
   */
  public static final MethodAccessFlag FINAL = new MethodAccessFlag( 0x0010, "final" );
  
  /** Declared synchronized; invocation is wrapped in a monitor lock.
   */
  public static final MethodAccessFlag SYNCHRONIZED = new MethodAccessFlag( 0x0020, "synchronized" );
  
  /** A bridge method, generated by the compiler.
   */
  public static final MethodAccessFlag BRIDGE = new MethodAccessFlag( 0x0040, "bridge" );

  /** Declared with variable number of arguments.
   */
  public static final MethodAccessFlag VARARGS = new MethodAccessFlag( 0x0080, "varargs" );

  /** Declared native; implemented in a language other than Java.
   */
  public static final MethodAccessFlag NATIVE = new MethodAccessFlag( 0x0100, "native" );
  
  /** Declared abstract; no implementation is provided.
   */
  public static final MethodAccessFlag ABSTRACT = new MethodAccessFlag( 0x0400, "abstract" );
  
  /** Declared strictfp; floating-point mode is FP-strict 
   */
  public static final MethodAccessFlag STRICT = new MethodAccessFlag( 0x0800, "strict" );
  
  /** Declared synthetic; Not present in the source code.
   */
  public static final MethodAccessFlag SYNTHETIC = new MethodAccessFlag( 0x1000, "synthetic" );

  /**
   * Creates a new MethodAccessFlag with the given name and value.
   *
   */
  protected MethodAccessFlag( int value, String name ) {
    mValue = value;
    mName = name;
  }
  
  /**
   * Returns a collection of the existing MethodAccessFlags.
   *
   */
  public static Collection<MethodAccessFlag> getFlags() {
  
    MethodAccessFlag[] flags = {
      PUBLIC,
      PRIVATE,
      PROTECTED,
      STATIC,
      FINAL,
      SYNCHRONIZED,
      BRIDGE,
      VARARGS,
      NATIVE,
      ABSTRACT,
      STRICT,
      SYNTHETIC
    };
  
    return Arrays.asList( flags );
  }
  
  /**
   * Returns the name used to represent the flag in Java source code.
   * For example, "public", "protected", etc ...
   *
   */
  public String getName() {
    return mName;
  }
  
  /**
   * Returns the value used to represent the flag in a Java class file.
   *
   */
  public int getValue() {
    return mValue;
  }
  
  /**
   * Returns true if this MethodAccessFlag is the same as obj.
   * MethodAccessFlags are equal if they have the same value.
   *
   */
  public boolean equals( Object obj ) {
    if ( obj instanceof MethodAccessFlag ) {
      return ( mValue == ( ( MethodAccessFlag ) obj ).mValue );
    }
  
    return false;
  }
  
  private int mValue;
  private String mName;
}